#pragma once
#include <motorSet.h>
#include <sensorSetPairController.h>
#include <IMUSensor.h>
#include <PID.h>

class MotorSetPairController {
    public:
        SensorSetPairController sensor_set_pair_controller;
        IMUSensor *imu_sensor;

        SensorSet front_sensor;
        SensorSet back_sensor;

        MotorSet front;
        MotorSet back;

        bool backward = false;

        void move(int pow, double direction) {
            front.move(pow, direction);
            back.move(pow, direction);
            // clear();
            // drawTextFmt(0, 0, WHITE, "front: %d, %d", front.left_speed, front.right_speed);
            // drawTextFmt(0, 10, WHITE, "back: %d, %d", back.left_speed, back.right_speed);
            // flip();
        }
        
        void forward(int pow) {
            move(pow, 0.0);  
        }

        void stop() {
            front.stop();
            back.stop();
        }

        void run_until_black(bool back_up = true, int pow = 60) {
            SensorSet* sensor = backward ? &back_sensor : &front_sensor;

            while (sensor->left->get_normalised() < 0.9 && sensor->right->get_normalised() < 0.9) {
                double ln = sensor_set_pair_controller.left->left->get_normalised();
                double rn = sensor_set_pair_controller.right->left->get_normalised();
                double direction = 0.0;

                if (!(ln < 0.9 && rn < 0.9)) {
                    double dir = ln - rn;
                    direction = constrain(dir, -1.0, 1.0);
                }
                
                move(pow, -direction);
            };

            move(-60, 0.0);
            delay(200);
            stop();
            
            align(!backward);
            if (back_up) {
                move(-20, 0.0);
                delay(400);
                stop();
            }
        }
        
        void run_until_white() {
            SensorSet* sensor = nullptr;
            double (SensorSet::*sensor_func)() = &SensorSet::get_normalised;
            sensor = backward ? &back_sensor : &front_sensor;

            while (sensor->get_normalised() > 0.1) {
                double direction = sensor_set_pair_controller.get_direction();
                move(50, direction);
                clear();
                drawTextFmt(0, 0, WHITE, "%f", direction);
                flip();
            };
        }

        bool check_front(float timeout = 2.0, bool back_up = true) {
            int start = millis();
            float elapsed = 0;
            bool found = false;
            while (elapsed < timeout) {
                elapsed = (millis() - start) / 1000.0;
                if (front_sensor.get_normalised() > 0.8) {
                    found = true;
                    break;
                }
                move(40, 0.0);
            }
            if (found) {
                align(true);
            }

            if (back_up) {
                move(-40, 0.0);
                delay(elapsed * 1000);
                stop();
            }

            return found;
        }

        void run(float tile = 1.0) {
            move((signbit(tile) ? -1 : 1) * 40, 0.0);
            delay(1100 * fabs(tile));
            stop();
        }

        PID alignPID = {0.5, 0.0, 0.5};
        PID rotatePID = {0.5, 0.0, 1.5};

        void align(bool backward = false) {
            SensorSet* sensor = backward ? &front_sensor : &back_sensor;
        
            int SEARCH_SPEED = backward ? -40 : 40;
            int ALIGN_SPEED  = backward ? -60 : 60;
        
            const double BLACK_MIN  = 0.5;
            const double CENTER_EPS = 0.1;
        
            while (sensor->get_normalised() < BLACK_MIN) {
                move(-SEARCH_SPEED, 0.0);
            }
            stop();
        
            alignPID.reset();
        
            unsigned long lastTime = millis();
            unsigned long start    = lastTime;
        
            while ((millis() - start) < 2000) {
                unsigned long now = millis();
                float dt = (now - lastTime) / 1000.0f;
                lastTime = now;
                if (dt <= 0) dt = 0.001f;
            
                double strength = sensor->get_normalised();
                double dir      = sensor->get_direction(); // desired = 0
            
                // Stop condition
                if (fabs(dir) < CENTER_EPS &&
                    fabs(strength - BLACK_MIN) < CENTER_EPS) {
                    break;
                }
            
                int fb = ALIGN_SPEED;
                if (strength < BLACK_MIN - CENTER_EPS) {
                    fb = -ALIGN_SPEED;
                } else if (strength > BLACK_MIN + CENTER_EPS) {
                    fb = ALIGN_SPEED;
                }
            
                float steer = alignPID.update(dir, dt);
            
                steer = constrain(steer, -1.0f, 1.0f);
            
                move(fb, -steer);
            }
        
            stop();
            delay(200);
            resetIMUToLastPerfect();
        }
        
        float norm180(float a) {
            while (a > 180) a -= 360;
            while (a < -180) a += 360;
            return a;
        }

        float getWorldYaw() {
            imu_sensor->getYaw();
            return norm180(worldYawOffset + imu_sensor->getYaw());
        }

        void resetIMUKeepWorld() {
            imu_sensor->getYaw();
            worldYawOffset = norm180(lastPerfectYaw - imu_sensor->getYaw());    
            imu_sensor->Reset();
        }

        void resetIMUToLastPerfect() {
            worldYawOffset = norm180(lastPerfectYaw);
            imu_sensor->Reset();
        }

        float worldYawOffset = 0.0f;
        float lastPerfectYaw = 0.0f;
        float continuousYaw = 0.0f;
        float lastYaw = 0.0f;
        bool yawInit = false;
        
        float unwrapYaw(float rawYaw) {
            if (!yawInit) {
                lastYaw = rawYaw;
                continuousYaw = rawYaw;
                yawInit = true;
                return continuousYaw;
            }
        
            float delta = rawYaw - lastYaw;
        
            // detect wrap (your IMU jumps ~370 deg)
            if (delta > 180)  delta -= 360;
            if (delta < -180) delta += 360;
        
            continuousYaw += delta;
            lastYaw = rawYaw;
        
            return continuousYaw;
        }

        const int   STALL_SPEED   = 40;
        const int   SPEED_MAX     = 80;
        const float STOP_EPS      = 0.05f;
        const float MAX_EFFORT   = 90.0f;

        int speedFromEffort(float effort) {
            float e = fabs(effort);
        
            float t = e / MAX_EFFORT;
            if (t > 1.0f) t = 1.0f;
        
            return STALL_SPEED +
                (int)((SPEED_MAX - STALL_SPEED) * t);
        }

        void rotate_to(float targetDeg) {
            targetDeg = norm180(targetDeg);
            rotatePID.reset();

            float prevError = 0.0f;
            bool first = true;

            uint32_t lastTime = millis();

            while (true) {
                uint32_t now = millis();

                float dt = (now - lastTime) * 0.001f;
                if (dt <= 0) dt = 0.001f;

                lastTime = now;

                float yaw   = getWorldYaw();
                float error = norm180(targetDeg - yaw);

                if (fabs(error) < STOP_EPS)
                    break;

                if (!first && (error * prevError < 0)) {
                    stop();
                    rotatePID.reset();
                    continue;
                }

                float effort = rotatePID.update(error, dt);

                float dir = (effort > 0) ? 1.0f : -1.0f;
                int speed = speedFromEffort(effort);

                move(speed, dir);

                prevError = error;
                first = false;
            }

            stop();

            lastPerfectYaw = targetDeg;
            resetIMUKeepWorld();
        }

};